{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/04/29/hello-world/"},{"title":"오라클 설치","text":"오라클 설치오라클 설치 오라클 데이터베이스 다운로드 (19c 버전) : https://www.oracle.com/kr/database/technologies/oracle19c-windows-downloads.html 다운받은 오라클 데이터베이스 파일 (WINDOWS.X64_193000_db_home) 압축을 푼다 압축 푼 파일 → data → setup.exe 우클릭 → 관리자 권한으로 실행후 다음과 같이 선택해준다 오라클 SQL과 PL/SQL을 다루는 기술 교재 20-22p 참고 → 전역 데이터 베이스 이름 : myoracle, 비번 : 1234, ‘컨테이너 데이터베이스로 생성’ 옵션 해제 설치하려는데 다음과 같은 오류 발생 - 일단 창 닫으니 설치가 진행되고 완료가 되었음 설치가 끝났으면 SQL Plus로 들어간다 (관리자 권한으로 실행) 테이블스페이스를 생성해준다 (oradata-MYORACLE이 있는 경로를 확인한다 → 나의 경우sql_lecture에 있음) 1CREATE TABLESPACE myts DATAFILE 'C:\\sql_lecture\\oradata\\MYORACLE\\myts.dbf' SIZE 100M AUTOEXTEND ON NEXT 5M; 그 다음 사용자를 생성한다 (여기서 ‘ohse’는 내 이름의 이니셜이다) 1CREATE USER ora_user IDENTIFIED BY ohse DEFAULT TABLESPACE MYTS TEMPORARY TABLESPACE TEMP; 롤을 부여한다 1GRANT DBA TO ora_user; 사용자 계정의 로 DB에 접속하기 연결을 먼저 해준다 1connect ora_user/ohse; 접속후 ‘select user from dual;’ 을 입력하면 현재 로그인한 사용자 이름이 출력된다 여기까지 완료되면 테이블 스페이스와 사용자가 제대로 생성된 것 SQL Developer 설치 : [https://www.oracle.com/tools/downloads/sqldev-downloads.html](https://www.oracle.com/tools/downloads/sqldev-downloads.html) 설치 후 압축을 푼다 파일로 들어가 sqldeveloper 응용프로그램을 관리자 권한으로 실행 파일 → 새 파일 만들기 → 아래와 같이 입력 후 test 시행 이 때 사용자 이름은 위에서 IDENTIFIED에 입력한 ora_user를 입력하고 비밀번호는 1234가 아니라 ohse를 입력하니까 실행되었음 테스트가 성공했으면 &lt;접속&gt;을 클릭 (혹은 &lt;접속&gt; 버튼이 없으면&lt;저장&gt; 후 접속하면 됨) 도구 → 환경설정 → 시간 기록 형식 (P)에 YYYY/MM/DD HH24:MI:SS로 바꾼다 질의 입력창에 SELECT user from DUAL;을 실행하고 ora_user가 뜨는지 확인해본다 c드라이브에 backup 폴더를 생성하고 expall.dmp와 expcust.dmp 파일을 넣어준다 파일 다운로드 링크 : [https://github.com/gilbutITbook/006696/blob/master/01장 환경설정/](https://github.com/gilbutITbook/006696/tree/master/01%EC%9E%A5%20%ED%99%98%EA%B2%BD%EC%84%A4%EC%A0%95) cmd(명령어 프롬프트)를 열고 경로를 backup 폴더로 잡아준다(cd 이용) 아래 코드 입력 imp ora_user/ohse file=expall.dmp log=empall.log ignore=y grants=y rows=y indexes=y full=y imp ora_user/ohse file=expcust.dmp log=expcust.log ignore=y grants=y rows=y indexes=y full=y SQL Developer 질의 입력 창에 ‘SELECT table_name FROM user_tables;’ 입력후 정상적으로 실행되는 지 확인 오라클 삭제 설치과정에 오류가 발생했을 때, 제일 좋은 해결책은 삭제하고 다시 설치하는 것! 우선 오라클 서비스를 중시 시킨다 [제어판] → [시스템 및 보안] →[관리도구] → [서비스] 메뉴를 실행해 Oracle로 시작되는 모든 서비스를 중지시킨다 삭제 파일시동하기 오라클 메인 폴더로 가서 (나의 경우 c드라이브-sql_lecture) [deinstall.bat] 파일을 관리자 권한으로 실행한다 삭제 진행하기 Oracle 홈에 구성된 데이터베이스 이름목록을 지정하라고 나오는데 [MYORACLE]을 입력하고 엔터를 누른다 삭제 확인하기 오라클 메인 폴더로 가서 파일이 남아 있는지 확인하고, 남아있다면 삭제한다","link":"/2022/04/29/ora_ins/"},{"title":"아나콘다 설치","text":"아나콘다 설치웹사이트 주소 : https://www.anaconda.com/products/individual 깃허브에서 R_edu프로젝트를 다운로드 받는다. 1$ git clone 주소 다운로드 누르기 관리자 권한으로 실행 advanced options는 모두 다 체크 설치 끝났으면 메뉴에서 아나콘다 네비게이트 실행 주피터랩 실행","link":"/2022/05/01/ana_ins/"},{"title":"파이참 설치","text":"파이참 설치 주소 : https://www.jetbrains.com/ko-kr/pycharm/download/#section=windows 윈도우-커뮤니티의 다운로드 클릭 installation options 다 체크하기 !! 마지막으로 시스템 환경 변수 편집에서 -환경 변수-시스템 편집-path편집-아나콘다 있는지 확인","link":"/2022/05/01/pyc_ins/"},{"title":"파이참 가상환경 세팅","text":"파이참 가상환경 세팅 file-close project new project 열고 browse에서 desktop→ 새 폴더 만들기(미리 만들어 놔도 됨) → 파일명 web 생성→생성된 web 클릭→ create 클릭 터미널-깃배쉬 which python-실행 시 /web/venv/Scripts/python이 경로가 보여야 함 (안될 때는 source venv/Scripts/activate) python main → main.py창에 import numpy as np, print(”numpy version: “,np.__version)→ python main.py (실행 안 될 거임, numpy가 설치가 안 되어있기 때문) → pip install numpy (라이브러리를 설치하는 명령) → 다시 python main.py 실행 (4/19) vscode-git bash로 가상환경 설치,실행이 안 됨 → 경로에 python 3.10 이 껴있어서 우선 파이참에서 우회해서(파일 만들기, 설치 등등은 파이참으로 진행하라는 말) vscode로 들어가서 작업해야 됨","link":"/2022/05/01/virt_set/"},{"title":"SQL basic","text":"SQLSELECT문 기본 구조 SELECT * 혹은 컬럼 —&gt; 무엇을 가져올껀지 FROM 테이블 또는 VIEW —&gt; 어디서 가져올껀지 WHERE 조건 —&gt; 어떻게 가져올껀지 ORDER BY 컬럼; 예시 (교재 3장) 123456SELECT employess_id, emp_name, salary, job_idFROM employeesWHERE salary &gt; 5000;ORDER BY employee_id; AND와 OR 조건 WHERE 조건에 AND나 OR의 옵션을 줄 수 있다 예시 1234567SELECT employess_id, emp_name, salary, job_idFROM employeesWHERE salary &gt; 5000; AND job_id ='IT_PROG'ORDER BY employee_id; MERGE 문 조건과 비교하여 값이 있으면 UPDATE / 없으면 INSERT를 진행해주는 구문 코드 실습 12345678# 테이블 만들기 INSERT INTO ex3_3 (employee_id)SELECT e.employee_idFROM employees e, sales sWHERE e.employee_id = s.employee_id AND s.SALES_MONTH BETWEEN '200010' AND '200012'GROUP BY e.employee_id; (1) 관리자 사번(manager_id)이 146번인 사원을 찾는다. (2) ex3_3 테이블에 있는 사원의 사번과 일치하면 보너스 금액에 자신의 급여의 1%를 보너스로 갱신 (3) ex3_3 테이블에 있는 사원의 사번과 일치하지 않으면 (1)의 결과의 사원을 신규로 입력(이 때 보너스 금액은 급여의 0.1% (4) 이 때 급여가 8000미만인 사원만 처리해보자. 123456SELECT employee_id, manager_id, salary, salary * 0.01FROM employeesWHERE employee_id IN (SELECT employee_id FROM ex3_3);# ex3_3 테이블에 있는 사원의 사번, 관리자 사번, 급여, 급여*0.01을 조회한 것# ex3_3 테이블에서 관리자 사번 146인 사원의 보너스 금액을 급여*0.01로 갱신 1234567SELECT employee_id, manager_id, salary, salary * 0.001FROM employeesWHERE employee_id NOT IN (SELECT employee_id FROM ex3_3) AND manager_id = 146;# 사원 테이블에서 관리자 사번이 146인 것 중 ex3_3 테이블에 없는 사원의 사번, 관리자 사번 급여, 급여*0.001을 조회한것 비교조건식 ANY OR 의 역할 급여가 2000 이거나 3000, 4000인 사원을 추출 123456SELECT employee_id , salaryFROM employeesWHERE salary = ANY(2000,3000,4000)ORDER BY employee_id; ALL AND 의 역할 모든 조건을 동시에 만족해야 함 123456SELECT employee_id , salaryFROM employeesWHERE salary = ALL(2000,3000,4000)ORDER BY employee_id; SOME ANY 와 같은 동작을 함 논리 조건식 AND OR NOT 조건식이 거짓일 때의 결과를 반환 NULL 조건식 특정 값이 NULL 인지 여부를 확인함 등호 연산자를 사용하지 않는다 “salary IS NULL” 혹은 “salary IS NOT NULL” BETWEEN AND 조건식 범위에 해당되는 값을 찾을 때 사용 ‘≥’ 와 ‘≤’ 논리 연산자로 변환이 가능 IN 조건식 조건에 포함된 값을 반환 ‘=ANY’ 형태로 바꿔 쓸 수 있음 비교나 등호 연산자 (‘=’) 를 쓰지 않음 123456SELECT employee_id , salaryFROM employeesWHERE salary IN (2000,3000,4000)ORDER BY employee_id; NOT IN 조건에 포함되지 않은 모든 값을 반환 마찬가지로 비교나 등호 연산자를 사용하지 않음 ‘&lt;&gt;ALL’ 이랑 같은 동작 EXISTS 조건식 IN과 비슷한 동작 서브 쿼리에만 사용 가능 LIKE 조건식 문자열의 패턴을 검색할 때 사용하는 조건식 % 위치에 따라 앞의 문자열에 대한 조건인지 뒤에 문자열에 대한 조건인지가 달라짐 사원 테이블에 사원 이름이 ‘A’로 시작되는 사원 조회 1234SELECT emp_nameFROM employeesWHERE emp_name LIKE 'A%'ORDER BY emp_name; ‘a’로 끝나는 사원 조회 1234SELECT emp_nameFROM employeesWHERE emp_name LIKE '%a'ORDER BY emp_name; ‘_’ (언더스코어)는 나머지 글자 전체가 아닌 한 글자만 비교 문자열 세번째가 ‘c’인 사원 조회 1234SELECT emp_nameFROM employeesWHERE emp_name LIKE '__c%'ORDER BY emp_name; SQL함수숫자함수 ABS 절댓값 반환 함수 ROUND 소수점 기준 n번째에서 반올림 소수점 1자리에서 반올림 1234SELECT ROUND(10.154,1) , ROUND(-10.154,1)FROM DUAL; 음수를 지정하면 일의 자리부터 시작하여 반올림 (-1을 지정하면 일의자리, -2를 지정하면 십의 자리에서) 12345SELECT ROUND(0, 3) , ROUND(115.155, -1) , ROUND(115.155, -2)FROM DUAL; TRUNC 절삭 함수 반올림이 아니라 n번째에서 절삭한다 123456SELECT TRUNC(115.155) ,TRUNC(115.155,1) ,TRUNC(115.155,2) ,TRUNC(115.155,-2)FROM DUAL; POWER(n2, n1) &amp; SQRT(n) 제곱과 제곱근 함수 POWER(3,2) = 9 / SQRT(9)=3 MOD, REMAINDER MOD는 n2를 n1으로 나눈 나머지 값을 반환 MOD(19,4) = 3 REMAINDER 또한 n2를 n1으로 나눈 나머지 값을 반환 내부적으로 계산 방법이 MOD와 약간 다름 REMAINDER(19, 4) = -1 EXP(n), LN, LOG EXP(n)은 지수함수로 n제곱 값을 반환 LN은 자연로그 함수로 밑수가 e인 로그 함수 LOG는 n2를 밑수로 하는 n1의 로그 값을 반환 문자함수 CONCAT(char1,char2) ‘||’ 연산자처럼 두 문자를 합쳐줌 CONCAT(’I Have’, ‘ A Dream’) = ‘I Have A Dream’ SUBSTR 문자 개수 단위로 문자열 자름 SUBSTR(‘ABCDEFG’,1, 4) = ‘ABCD’ SUBSTRB 문자열의 바이트 수만큼 자름 SUBSTRB(’ABCDEFG’,1,4) = ‘ABCD’ LTRIM(char,set), RTRIM(char,set) LTRIM은 char 문자열에서 set으로 지정된 문자열을 왼쪽 끝에서 제거한 후 나머지 문자열 반환 RTRIM은 반대로 오른쪽 끝에서 제거한 뒤 나머지 문자열 반환 set은 생략 가능 LTRIM(‘가나다라’, ‘가’) = 나다라 RTRIM(’가나다라’,’라’) = 가나다 보통 양 끝에 있는 공백을 제거할 때 자주 사용 LPAD, RPAD LPAD는 매개변수로 들어온 문자열을 n자리만큼 왼쪽부터 채워 추가된 문자열을 반환 RPAD는 오른쪽에 해당 문자열을 채워 반환 123456789101112CREATE TABLE ex4_1( phone_num VARCHAR(30));INSERT INTO ex4_1 VALUES('111-1111');INSERT INTO ex4_1 VALUES('111-2222');INSERT INTO ex4_1 VALUES('111-33333');SELECT * FROM ex4_1;SELECT LPAD(phone_num,12,'(02)') FROM ex4_1; # (02)111-1111 ...SELECT RPAD(phone_num,12,'(02)') FROM ex4_1; # 111-1111(02_ ... REPLACE(char, search_str, replace_str) 문자열에서 바꿀 문자열을 찾아, 바꾸려는 문자열로 대체하는 것 TRANSLATE(expr, FROM_str, to_str) replace와 비슷하지만 translate은 문자열 자체가 아닌 한 글잤기 매핑해 바꾼 결과를 반환 날짜함수 SYSDATE, SYSTIMESTAMP 현재 일자를 알려줌 / 현재 일자와 시간을 알려줌 ADD_MONTHS( date, integer) 매개변수로 들어온 날짜에 integer만큼의 월을 더한 날짜를 반환 MONTHS_BETWEEN(date1, date2) 두 날짜 사이의 개월 수를 반환 LAST_DAY(date) date 날짜를 기준으로 해당 월의 마지막 일자를 반환 ROUND(date, format), TRUNC(date, format) ROUND는 format에 따라 반올림한 날짜를 , TRUNC는 잘라낸 날짜를 반환 NEXT_DAT(date, char) date를 char에 명시한 날짜로 다음 주 주중 일자를 반환 변환함수 서로 다른 유형의 데이터 타입으로 변환해 결과를 반환하는 함수 TO_CHAR(숫자 혹은 날짜, format) 숫자나 날짜를 문자로 변환해 주는 하무 날짜 변환 형식 숫자 변환 형식 TO_NUMBER 문자나 다른 유형의 숫자를 NUMBER형으로 변환하는 함수 TO_DATE (char, format), TO_TIMESTAMP (char, format) 문자를 날짜형으로 변환하는 함수 TO_DATE는 DATE형으로 TO_TIMESTAMP는 TIMESTAMP형으로 변환 NULL 관련 함수 NVL(expr1, expr2), NVL2((expr1, expr2, expr3)) NVL 함수는 expr1이 NULL일 때 expr2를 반환한다 NVL2 함수는 NVL을 확장한 함수로 expr1이 NULL 이 아니면 expr2를, NULL이면 expr3을 반환하는 함수이다 커미션이 NULL인 사원은 그냥 급여를 NULL이 아닌 사원은 급여 + (급여 * 커미션)을 조회하는 쿼리 123SELECT employee_id, NVL2(commission_pct, salary + (salary * commission_pct),salary) AS salary2FROM employees; COALESCE (expr1, expr2..) 매개변수로 들어오는 표현식에서 NULL이 아닌 첫번째 표현식을 반환하는 함수 급여 * 커미션 값이 NULL이면 salary를, NULL 이 아니면 급여 * 커미션을 반환하는 쿼리 123SELECT employee_id, salary, commission_pct, COALESCE (salary * commission_pct, salary) AS salary2FROM employees; LNNVL (조건식) 매개변수로 들어오는 조건식의 결과가 FALSE나 UNKNOWN이면 TRUE를, TRUE이면 FALSE를 반환한다 커미션이 0.2이하인 사원 조회 (null도 포함하여) 123SELECT COUNT(*) FORM employeesWHERE LNNVL(commission_pct &gt;= 0.2); NULLIF (expr1, expr2) expr1과 expr2를 비교해 같으면 NULL을 같지 않으면 expr1을 반환한다 job_history 테이블에서 start_date와 end_date의 연도만 추출해 두 연도가 같으면 NULL을, 같지 않으면 종료 년도를 출력하는 쿼리 12345SEELECT employee_id ,TO_CHAR(start_date,'YYYY')start_year ,TO_CHAR(end_date, 'YYYY') end_year , NULLIF(TO_CHAR(end_date, 'YYYY'), TO_CHAR(start_date, 'YYYY')) nullif_yearFROM job_history; 기타 함수 GREATEST(expr1, expr2…), LEAST(expr1, expr2…) GREATEST는 매개변수로 들어오는 표현식에서 가장 큰 값을, LEAST는 가장 작은 값을 반환하는 함수 DECODE(expr, search1, result1, search2, result2, …, default) expr과 search1을 비교해 두 값이 같으면 result1을 , 같지 않으면 다시 search2와 비교해 값이 같으면 result2를 반환… 이런 식으로 계속 비교한 뒤 최종적으로 같은 값이 없으면 default 값을 반환 그룹 쿼리 COUNT (expr) 전체 로우 혹은 조건으로 걸러진 로우 수를 반환하는 집계 함수 대부분은 COUNT(*) 형태로 사용하는데 *에 컬럼명을 넣기도 함 또한 COUNT함수는 매개변수가 NULL이 아닌 건에 대해서만 로우의 수를 반환 앞에 DISTINCT를 붙이면 컬럼에 있는 유일한 값만 조회됨 SUM (expr) 전체 합계를 반환하는 함수 COUNT와 마찬가지로 DISTINCT를 쓸 수 있음 AVG (expr) 매개변수의 평균값을 반환하는 함수 MIN(expr), MAX(expr) 각각 최솟값과 최댓값을 반환 DISTINCT를 사용할 수는 있지만 각각 최솟값과 최댓값을 반환하므로 굳이 DISTINCT를 사용할 필요는 없음 VARIANCE(expr), STDDEV(expr) VARIANCE 는 분산을, STDDEV는 표준편차를 구해 반환하는 함수 GROUP BY 절과 HAVING절 특정 그룹으로 묶어 데이터를 집계해주는 함수 WHERE와 ORDER BY절 사이에 위치함 사원테이블의 각 부서별 급여 총액 구하기 1234SELECT department_id, SUM(salary)FROM employeesGROUP BY department_idORDER BY department_id; HAVING절은 GROUP BY 절 다음에 위치해 GROUP BY한 결과를 대상으로 다시 필터를 거는 역할 2013년 지역별 가계 대출 총 잔액에서 대출 잔액이 100조 이상인 건만 추출하기 123456SELECT period, region, SUM(loan_jan_amt) totl_janFROM kor_loan_statusWHERE period = '201311'GROUP BY period, regionHAVING SUM(loan_jan_amt) &gt; 100000ORDER BY region; ROLLUP절과 CUBE절 둘다 GROUP BY 절에서 사용되며 그룹별 소계를 추가로 보여주는 역할을 함 ROLLUP은 expr로 명시한 표현식을 기준으로 집계한 결과, 즉 추가적인 집계 정보를 보여줌 2013년도 대출 종류별 총 잔액에 롤업 적용 → 12345SELECT period, gubun, SUM(loan_jan_amt) totl_janFROM kor_loan_statusWHERE period LIKE '2013%'GROUP BY period, gubunORDER BY ROLLUP(period, gubun); CUBE는 rollup이 레벨별로 순차적 집계를 한 반면, 명시한 표현식 개수에 따라 가능한 모든 조합별로 집계한 결과를 반환한다 CUBE는 2의 제곱(expr 수) 만큼 종류별로 집계 된다. 집합연산자 UNION 합집한을 의미 → 데이터 집합 각각의 집합 원소를 모두 포함한 결과가 반환됨 UNION ALL UNION과 비슷한데 중복된 항목도 모두 조회해주는 함수 INTERSECT 교집합을 의미 → 데이터 집합에서 공통된 항목만을 추출 MINUS 차집합을 의미 → 한 데이터 집합을 기준으로 다른 데이터 집합과 겹치는 항목을 제외하여 결과를 추출 조인내부조인과 외부조인 동등조인 WHERE절에서 등호 연산자를 사용해 2개 이상의 테이블이나 뷰를 연결한 조인 A와 B 테이블 사이에서 공통된 값을 가진 컬럼의 행을 추출 123456789SELECT a.employee_id , a.emp_name , a.department_id , b.department_nameFROM employees a , departments bWHERE a.department_id = b.department_id; EXISTS 서브 쿼리를 사용해 서브 쿼리에 존재하는 데이터만 메인 쿼리에서 추출하는 조인 방법 B 테이블에 존재하는 A 테이블의 데이터를 추출 12345678910SELECT department_id , department_nameFROM departments aWHERE EXISTS (SELECT * FROM employees b WHERE a.department_id = b.department_id AND b.salary &gt; 3000 ) --- EXISTSORDER BY a.department_name; IN 서브 쿼리 내에 두 테이블의 조인 조건이 없다 IN 연산자는 OR 조건을 반환 가능 123456789SELECT department_id , department_nameFROM departments aWHERE a.department_id IN (SELECT b.department_id FROM employees b WHERE b.salary &gt; 3000)ORDER BY a.department_name; 외부조인 (+) 기호를 붙이는 형식 조인 조건에 만족하지 않더라도 데이터를 모두 추출함 (없으면 null값으로 출력) 12345678SELECT a.department_id , a.department_name , b.job_id , b.department_idFROM departments a , job_history bWHERE a.department_id = b.department_id(+); 외부조인 시 조인 조건 모두에 (+)를 붙여야 함 12345678910SELECT a.employee_id , a.emp_name , b.job_id , b.department_idFROM employees a , job_history bWHERE a.employee_id = b.employee_id(+) AND a.department_id = b.department_id(+); 카타시안 조인 WHERE절에 조인 조건이 없는 조인 방식 FROM절에 2개 이상 테이블을 명시했으므로 일종의 조인 조건 1234567891011SELECT a.employee_id , a.emp_name , a.hire_date , b.department_id , b.department_nameFROM employees a , departments bWHERE a.department_id = b.department_id AND a.hire_date &gt;= TO_DATE('2003-01-01','YYYY-MM-DD'); ANSI 조인 조인 조건이 WHERE 절이 아닌 FROM 절에 들어간다는 점이 기존 문법과 다름 FROM 절에서 INNER JOIN 구문을 사용하며, 조인 조건은 ON 절에 , 조인 조건 외의 조건은 기존대로 WHERE 절에 명시 1234567891011SELECT a.employee_id , a.emp_name , a.hire_date , b.department_id , b.department_nameFROM employees aINNER JOIN departments b ON (a.department_id = b.department_id)WHERE a.hire_date &gt;= TO_DATE('2003-01-01','YYYY-MM-DD'); 서브쿼리 연관성 없는 서브 쿼리 메인 쿼리와의 연관성이 없는 서브쿼리를 말한다 메인 테이블과 조인 조건이 걸리지 않는 서브쿼리 메인 쿼리: 모든 사원 테이블을 조회하라 / 서브 : 사원 테이블의 평균 급여보다 많은 사원 123SELECT *FROM employeesWHERE salary &gt;= (SELECT AVG(salary) FROM employees); parent_id 가 null인 부서번호를 가진 총 사원의 건수 12345SELECT count(*)FROM employeesWHERE department_id IN (SELECT department_id FROM departments WHERE parent_id IS NULL); 연관성이 있는 서브 쿼리 메인쿼리와의 연관성이 있는 서브 쿼리 메인 테이블과 조인 조건이 걸린 서브 쿼리 메인: 부서 번호를 조회하라 / 서브 : 부서테이블의 부서번호와 job_history 테이블의 부서 번호가 같은 경우를 조회하라 1234567SELECT a.department_id , a.department_nameFROM departments aWHERE EXISTS(SELECT 1 FROM job_history b WHERE a.department_id = b.department_id); 두 개의 서브쿼리(중첩 쿼리) 사용 연관성 없는 서브쿼리 :평균 급여를 구하고 이 값보다 큰 급여의 사원을 조회 연관성 있는 서브쿼리: 평균급여 이상을 받는 사원이 속한 부서를 추출 12345678SELECT a.department_id, a.department_nameFROM departments aWHERE EXISTS (SELECT 1 FROM employees b WHERE a.department_id = b.department_id AND b.salary &gt; (SELECT AVG(salary) FROM employees) ); 인라인 뷰 FROM절에 사용하는 서브 쿼리 2000년 이탈리아 평균 매출액(연평균)보다 큰 월의 평균 매출액 구하기 서브 1 : 월별 평균 매출액 구하는 것 서브 2 : 연평균 매출액을 구하는 것 1234567891011121314151617SELECT a.*FROM (SELECT a.sales_month, ROUND(AVG(a.amount_sold)) AS month_avg FROM sales a, customers b, countries c WHERE a.sales_month BETWEEN '200001' AND '200012' AND a.cust_id = b.CUST_ID AND b.COUNTRY_ID = c.COUNTRY_ID AND c.COUNTRY_NAME = 'Italy' GROUP BY a.sales_month) a , (SELECT ROUND(AVG(a.amount_sold)) AS year_avg FROM sales a , customers b , countries c WHERE a.sales_month BETWEEN '20001' AND '200012' AND a.cust_id = b.CUST_ID AND b.COUNTRY_ID = c.COUNTRY_ID AND c.COUNTRY_NAME = 'Italy' ) bWHERE a.month_avg &gt; b.year_avg; ERD를 통해 도식화해서 보는 것을 추천 ERD : 데이터베이스 구조를 한 눈에 알아보기 위해 고급 쿼리 복잡한 연산 결과를 추출해 내는 쿼리 작성법 (1),(2) 메인쿼리 작성 (3),(4) 서브쿼리 작성 후 합치기 이탈리아 매출액 데이터에서 연도별 매출 실적이 가장 많은 사원의 목록과 최대 매출액 이탈리아 고객 찾기 —&gt; customers, countries country_id로 조인 이탈리아 매출액 찾기 —&gt; 위의 결과와 sales 테이블을 cust_id 로 조인 최대 매출액은 MAX, 연도별은 GROUP BY로 12345678910111213# (1)SELECT SUBSTR(a.sales_month, 1, 4) as years , a.employee_id , SUM(a.amount_sold) AS amount_soldFROM sales a , customers b , countries c WHERE a.cust_id = b.cust_id AND b.country_id = c.country_id AND c.country_name = 'Italy' GROUP BY SUBSTR(a.sales_month, 1, 4), a.employee_id; 12345678910111213141516171819# (2) SELECT years , MAX(amount_sold) AS max_sold , MIN(amount_sold) AS min_soldFROM (SELECT SUBSTR(a.sales_month, 1, 4) as years , a.employee_id , SUM(a.amount_sold) AS amount_sold FROM sales a , customers b , countries c WHERE a.cust_id = b.cust_id AND b.country_id = c.country_id AND c.country_name = 'Italy' GROUP BY SUBSTR(a.sales_month, 1, 4), a.employee_id) K GROUP BY yearsORDER BY years; 1234567891011121314151617181920212223242526272829303132333435363738394041# (1) + (2)SELECT emp.years , emp.employee_id , emp2.emp_name , emp.amount_soldFROM (SELECT SUBSTR(a.sales_month, 1, 4) as years , a.employee_id , SUM(a.amount_sold) AS amount_sold FROM sales a , customers b , countries c WHERE a.cust_id = b.cust_id AND b.country_id = c.country_id AND c.country_name = 'Italy' GROUP BY SUBSTR(a.sales_month, 1, 4), a.employee_id) emp , (SELECT years , MAX(amount_sold) AS max_sold , MIN(amount_sold) AS min_sold FROM (SELECT SUBSTR(a.sales_month, 1, 4) as years , a.employee_id , SUM(a.amount_sold) AS amount_sold FROM sales a , customers b , countries c WHERE a.cust_id = b.cust_id AND b.country_id = c.country_id AND c.country_name = 'Italy' GROUP BY SUBSTR(a.sales_month, 1, 4), a.employee_id) K GROUP BY years) sale , employees emp2WHERE emp.years = sale.years AND emp.amount_sold = sale.max_sold AND emp.employee_id = emp2.employee_idORDER BY years; 분석함수 그룹 별 집계를 담당 종류 WINDOW 절 : 파티션으로 분할된 그룹에 대해서 더 상세한 그룹으로 분할할 때 사용 ORDER BY 절 : 파티션 안에서의 순서를 지정 PARTITION BY 절 : 분석함수로 계산될 대상 로우의 그룹을 지정 ROW_NUMBER() 파티션으로 분할된 그룹별 각 로우에 대한 순번을 반환하는 함수 사원 테이블에서 부서별 사원들의 로우 수 출력 123456SELECT department_id , emp_name , ROW_NUMBER() OVER (PARTITION BY department_id ORDER BY emp_name) dep_rowsFROM employees; RANK(), DENSE_RANK() 파티션별 순위 반환 부서별로 급여 순위 매기기 123456789SELECT department_id , emp_name , salary , RANK() OVER (PARTITION BY department_id ORDER BY salary) dep_rank , DENSE_RANK() OVER (PARTITION BY department_id ORDER BY salary) dep_denserankFROM employees; CUME_DIST &amp; PERCENT_RANK CUME_DIST : 주어진 그룹에대한 상대 누적 분포도값 반환 123456SELECT department_id , emp_name , CUME_DIST() over (PARTITION BY department_id ORDER BY salary) dep_distFROM employees; NTILE 함수 NTILE(4) 값을 4등분 함 12345678SELECT department_id , emp_name , salary , NTILE(5) OVER (PARTITION BY department_id ORDER BY salary) NTITLESFROM employeesWHERE department_id IN (30,60); LAG 함수 &amp; LEAD 함수 LAG : 선행 로우의 값 참조 LEAD : 후행 로우의 값 참조 12345678SELECT emp_name , hire_date , salary , LAG(salary, 1, 0) OVER (ORDER BY hire_date) AS prev_sal , LEAD(salary, 1, 0) OVER (ORDER BY hire_date) AS next_salFROM employeesWHERE department_id 계층형 쿼리 계층형 구조 : 상하 수직 관계의 구조로 사원-대리-과장-부장/ 판매부-영업부 같은 구조가 속한다 또 다른 말로는 부모 컬럼, 자식 컬럼이라고도 표현한다 계층형 쿼리 구문 START WITH 조건 : 최상위 계층의 로우를 식별, 즉 이 조건에 맞는 로우부터 계층형 구조를 풀어나간다는 의미 CONNECT BY 조건 : 계층형 구조가 어떤식으로 연결되는지를 기술 부서 테이블은 parent_id 에 상위 부서 정보를 갖고 있음 → ‘CONNECT BY PRIOR department_id (자식 컬럼) = parent_id (부모 컬럼)’ CONNECT BY NOCYCLE 은 무한루프를 방지하기 위한 조건 12345SELECT expr1, expr2,...FROM 테이블WHERE 조건START WITH [최상위 조건]CONNECT BY [NOCYCLE][PRIOR 계층형 구조조건]; WITH절 동일한 구문을 연결시켜줌 WITH이 맨 앞에 오고 별칭을 앞에 명시한다는 점을 빼고는 일반 서브 쿼리와 비슷함 형식 12WITH 별칭1 AS (SELECT문), 별칭2 AS (SELECT문) 분석함수 특정 그룹별 집계를 해주므로 집계함수에 속함 AVG WINDOW 함수 파티션으로 분할된 그룹에 대해 별도로 다시 그룹(=부분집합)을 만드는 역할을 함 구문 형식 ROWS : 로우 단위로 WINDOW절을 지정 RANGE : 로우가 아닌 논리적인 범위로 WINDOW 절을 지정 BETWEEN ~ AND : WINDOW 절의 시작과 끝 지점을 명시 UNBOUNDED PRECEDING : 파티션으로 구분된 첫번째 로우를 시작 지점 UNBOUNDED FOLLOWING : 파티션으로 구분된 마지막 로우를 끝 지점 CURRENT ROW : 시작 및 끝 지점이 현재 로우가 됨 value_expr PRECEDING : 끝 지점일 경우, 시작 지점은 value_expr PRECEDING value_expr FOLLOWING : 시작 지점일 경우, 끝 지점은 value_expr FOLLOWING 📌 SQL 책 추천 : 데이터 분석을 위한 SQL 레시피 (한빛 미디어, 가사키 나가토)","link":"/2022/05/01/SQL_basic/"},{"title":"crawling basic","text":"크롤링 기초Python웹상에 있는 데이터를 수집하는 도구 BeautifulSoup 가장 일반적인 수집 도구 (CSS 통해서 수집) Scrapy (CSS, XPATH) Selenium (CSS, XPATH 통해서 데이터 수집 + JavaScript) —&gt; 자바 필요 + 몇개의 설치 도구 필요 웹사이트 만드는 3대 조건+1 HTML, CSS, JavaScript, Ajax (비동기처리) 웹사이트 구동 방식 GET / POST 참고 네이버 같은 사이트에서 마우스 우클릭 → 검사로 가면 그 페이지의 html 형태? 를 볼 수 있다 파이참으로 실습 crawling 프로젝트 파일 생성 (가상환경 세팅) 상단 탭 File → Settings → Project: crawling → Python Interpreter → 세팅 아이콘 클릭 → add 클릭 → new environment 클릭 터미널에서 가상환경 세팅(source venv/Scripts/activate 명령어 입력) 후 필요한 라이브러리들 설치 (pandas, numpy, beautifulsoup4, requests 등등) html 파일을 만든다 (crawling 우클릭→ new → html) 파일명은 임의로 index로 설정 html의 기본 구조 ( ,) 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;=&quot;UTF-8&quot;&gt; &lt;titl&gt; CRAWLING TEST &lt;/titl&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;aaaaaaa&lt;/h1&gt; &lt;h2&gt;bbbbbbbb&lt;/h2&gt; &lt;div class=&quot;chapter01&quot;&gt; &lt;p&gt; DON'T CRAWL HERE &lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;chapter02&quot;&gt; &lt;p&gt; JUST CRAWLING HERE &lt;/p&gt; &lt;/div&gt; &lt;div id = &quot;main&quot;&gt; &lt;p&gt; crawling&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 뉴스 헤드라인 크롤링 네이버 → 우클릭 : 검사 → 네트워크 → 문서 → 헤더에서 요청메서드가 get 방식인지 확인 라이브러리( 기본 : bs4, requests) 임포트 한다 referer에는 사이트 검사에서 찾은 referer 복사, user-agent 도 복붙 req. status_code를 했을 때 200이 나오면 정상, 404 주소오류, 503은 서버가 내려진 상태 1234567891011121314def main(): CUSTOM_HEADER= { 'referer':'https://www.naver.com/', 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36' } url = 'https://www.naver.com/' req = requests.get(url = url, headers=CUSTOM_HEADER) print(req.status_code) print(req.text) # print(&quot;크롤링 완성!&quot;)if __name__ == &quot;__main__&quot;: main() 벅스 차트 크롤링 검사 → 네트워크 → 닥스 → 헤더에서 referer확인 및 user-agent 확인 (* referer는 항상 있는게 아니라 없을 때도 있음, 그럼 안 쓰면 된다) url 에는 request URL(요청 URL) 을 넣는다 상태코드로 웹사이트 들어갔는지 확인 BeautifulSoup으로 실행 12345678910111213141516171819202122232425import requestsfrom bs4 import BeautifulSoupimport pandas as pddef main(): CUSTOM_HEADER = { 'user-agent' : 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36' } url = 'https://music.bugs.co.kr/chart' req = requests.get(url = url, headers=CUSTOM_HEADER) if req.status_code == 200: print(&quot;상태코드 : &quot;, req.status_code) print(&quot;실행&quot;) soup = BeautifulSoup(req.text, 'html.parser') crawling(soup) else: print(&quot;웹사이트 확인하세요&quot;, url) # soup = BeautifulSoup(req.text, 'html.parser') # crawling(soup)if __name__ == &quot;__main__&quot;: main() 사용자 정의 함수 crawling으로 가서 차트가 어디 태그에 속해있는지 확인 (차트의 최상위 태그는 tbody, class는 없으므로 생략한다) 타이틀은 p태그 안에 있으므로 반복문으로 뽑는다 p태그는 타이틀말고도 다른 텍스트에도 달려있으므로 클래스를 타이틀로 지정하여 타이틀만 뽑도록한다 p.get_text()로 잘 나왔는지 출력해본다 ‘\\n’ 문자열까지 나왔으므로 이를 제거하고 출력해준다 (* strip(’\\n’)) 배열로 변환된 결과를 출력한다 1234567891011121314def crawling(soup): print(&quot;크롤링 완성!&quot;) tbody_df = soup.find(&quot;tbody&quot;) # print(tbody_df) result = [] for p in tbody_df.find_all(&quot;p&quot;, class_=&quot;title&quot;): print(p.get_text().strip('\\n')) # (1) result.append(p.get_text().strip('\\n')) # result.append(p.get_text().replace(&quot;\\n&quot;, &quot;&quot;)) # (2) print(result)","link":"/2022/05/01/crawling/"},{"title":"PL&#x2F;SQL basic","text":"PL/SQL 기본 구조 블록 선언부 ,실행부, 예외 처리부로 구성됨 이름부 : 블록의 명칭이 오는 자리, 생략하면 익명 블록이 됨 선언부 : DECLARE로 시작, 각종 변수, 상수, 커서 등을 선언 실행부 : 실제 로직을 처리하는 부분, 일반 SQL문, 조건문, 반복문 등이 오는 자리 예외 처리부 : EXCEPTION 절로 시작, 실행부에서 오류가 발생하면 처리한 내용을 기술하는 부분, 생략이 가능 주의 : 문장 끝마다 세미콜론(;)을 붙여야 오류 없이 실행 됨 익명 블록 이름이 없는 블록 vi_num이란 NUMBER형 변수 선언 PL/SQL에서 값의 할당은 등호가 아닌 ‘:=’로 처리 vi_num에 100 할당 DBMS_OUTPUT 패키지는 괄호 안에 있는 매개변수 값을 출력해줌 1234567DECLARE vi_num NUMBER;BEGIN vi_num := 100; DBMS_OUTPUT.PUT_LINE(vi_num)END; 출력하려면 ‘SET SERVEROUTPUT ON’ 을 맨 앞에 추가해야함 총 소요시간은 ‘SET TIMING ON’ 명령어를 실행 123456789SET SERVEROUTPUT ONSET TIMING ONDECLARE vi_num NUMBER;BEGIN vi_num := 100; DBMS_OUTPUT.PUT_LINE(vi_num)END; PL/SQL 구성요소 변수 변수는 다른 프로그래밍 언어에서 사용하는 변수와 개념이 같음 선언부에서 변수 선언을 하고 실행부에서 사용하는 방식 변수명 데이터 타입 := 초깃갑; 이때 초깃값을 할당하지 않으면 NULL이 됨 변수로 선언 가능한 데이터 타입에는 SQL데이터 타입과 PL/SQL 데이터 타입이 존재 정확히 말하면 PL/SQL에 SQL 데이터 타입이 포함 PL/SQL에만 있는 데이터 타입 BOOLEAN PLS_INTEGER BINARY_INTEGER 상수 변수와 달리 한 번 값을 할당하면 변하지 않음 상수면 CONSTANT 데이터 타입 := 상수값; 상수 선언시 반드시 CONSTANT를 붙여 변수와 구분함 연산자 DML문 실행하거나 출력하는 것이 아닌 조작하는 언어 사원 테이블에서 특정 사원의 이름과 부서명을 가져와 출력하는 코드 1234567891011DECLARE vs_emp_name VARCHAR2(80); --사원명 변수 vs_dep_name VARCHAR2(80); --부서명 변수BEGIN SELECT a.emp_name, b.department_name INTO vs_emp_name, vs_dep_name FROM employees a, departments b WHERE a.department_id = b.department_id AND a.employee_id = 100;DBMS_OUTPUT.PUT_LINE (vs_emp_name || '-' || vs_dep_name);END; *중요 : 테이블에 있는 데이터를 선택해 변수에 할당할 때는 SELECT 문에서 INTO 절을 사용한다 따로 변수 타입을 선언하기 번거로울 때는 %TYPE 키워드로 대체 가능 1234567891011DECLARE vs_emp_name employees.emp_name%TYPE; --사원명 변수 vs_dep_name departments.department_name%TYPE; --부서명 변수BEGIN SELECT a.emp_name, b.department_name INTO vs_emp_name, vs_dep_name FROM employees a, departments b WHERE a.department_id = b.department_id AND a.employee_id = 100;DBMS_OUTPUT.PUT_LINE (vs_emp_name || '-' || vs_dep_name);END; 라벨 PL/SQL 코드가 길어질 때 특정 블록 단위로 라벨을 붙이면 가독성이 좋아져서 유용 반복문에 라벨을 붙이면 조건에 따라 EXIT 문으로 해당 반복문 빠져 나오는거 쉬움 조건문 (IF문) 급여가 3500이상이면 고연봉자, 2000이상이면 중간 연봉자, 그 외에는 저연봉자로 구분하는 조건문 1234567IF v_sal &gt;= 3500 THEN DBMS_OUTPUT.PUT_LINE('high salary'); ELSIF v_sal &gt;= 2000 THEN DBMS_OUTPUT.PUT_LINE('middle salary'); ELSE DBMS_OUTPUT.PUT_LINE('low salary'); END IF; 반복문 가장 기본적인 형태는 LOOP문 구구단 123456789DECLARE v_count number(10):= 0;BEGIN LOOP v_count := v_count +1; DBMS_OUTPUT.PUT_LINE('2 x ' || v_count || ' = ' || 2 * v_count); EXIT WHEN v_count = 9; END LOOP;END;","link":"/2022/05/02/PLSQL/"},{"title":"에어플로 설치","text":"Airflow 세팅 airflow 설치를 위해 pip을 설치한다 1$ sudo apt install python3-pip virtualenv 라이브러리를 설치한다 1$ sudo pip3 install virtualenv c드라이브에 airflow-test 파일을 생성 후 해당 디렉토리로 들어간다 123$ cd mnt$ cd c$ cd airflow-test 가상환경을 생성한다 1$ virtualenv venv 가상환경에 접속한다 (&lt;&gt; 가상환경에서 나오는 거는 deactivate 입력) 1$ source venv/bin/activate .bashrc 파일을 수정한다 1$ vi ~/.bashrc 아래와 같이 입력되었는지 확인 1export AIRFLOW_HOME=/mnt/c/airflow-test 참고 : vi 편집기를 수정했으면 꼭 source로 업데이트 해줘야 함 1$ source ~/.bashrc 꼭 에코로 잘 들어가 있는 지 확인해본다 1$ echo $AIRFLOW_HOME pwd(현재 경로를 알려줌)을 쳐서 같은지 확인 1$ pwd PostgreSQL, Slack, Celery 패키지를 동시에 설치하는 코드를 작성한다 1$ pip3 install 'apache-airflow[postgres, slack, celery]' 에어플로 실행을 위해 DB를 초기화 (이때 가상환경에 접속되어 있어야함, 안 되어 있음 다시 접속 ) 1$ airflow db init 계정을 생성한다 1$ airflow users create --username airflow --password airflow --firstname evan --lastname airflow --role Admin --email your_email@some.com vscode의 cfg 파일에 load_examples=False 로 바꿔준다 airflow db reset airflow webserver -p 8080 ubuntu에서 dags 파일을 만든다, 데이터 파일도 만든다 1$ mkdir dags 1$ mkdir data 데이터 디렉터리로 들어간다 1$ cd data step01_writecsv.py를 vi 편집기로 들어간다 1$ vi step01_writecsv.py step01_writecsv.py에 내용을 추가한다 12345678910from faker import Fakerimport csvoutput=open('data.csv','w')fake=Faker()header=['name','age','street','city','state','zip','lng','lat']mywriter=csv.writer(output)mywriter.writerow(header)for r in range(1000): mywriter.writerow([fake.name(),fake.random_int(min=18, max=80, step=1), fake.street_address(), fake.city(),fake.state(),fake.zipcode(),fake.longitude(),fake.latitude()])output.close() 저장하고 나와서 파일을 확인해본다 1$ ls dags 디렉토리로 가서 csv2json.py파일을 생성한다 12$ cd dags$ vi csv2json.py 내용을 입력한다 12345678910111213141516171819202122232425262728293031323334import datetime as dtfrom datetime import timedeltafrom airflow import DAGfrom airflow.operators.bash import BashOperatorfrom airflow.operators.python import PythonOperatorimport pandas as pddef csvToJson(): df=pd.read_csv('data/data.csv') for i,r in df.iterrows(): print(r['name']) df.to_json('fromAirflow.json',orient='records')default_args = { 'owner': 'evan', 'start_date': dt.datetime(2020, 3, 18), 'retries': 1, 'retry_delay': dt.timedelta(minutes=5),}with DAG('MyCSVDAG', default_args=default_args, schedule_interval=timedelta(minutes=5), # '0 * * * *', ) as dag: print_starting = BashOperator(task_id='starting', bash_command='echo &quot;I am reading the CSV now.....&quot;') csvJson = PythonOperator(task_id='convertCSVtoJson', python_callable=csvToJson)print_starting &gt;&gt; csvJ 웹 서버랑 스케쥴러를 실행한다 가상환경 tip: export AIRFLOW_HOME = “$(pwd)” vscode는 파일 열기를 통해 파일을 바꿔준다","link":"/2022/05/03/Airflow/"}],"tags":[{"name":"oracle","slug":"oracle","link":"/tags/oracle/"},{"name":"sql","slug":"sql","link":"/tags/sql/"},{"name":"crawling","slug":"crawling","link":"/tags/crawling/"},{"name":"PL&#x2F;SQL","slug":"PL-SQL","link":"/tags/PL-SQL/"},{"name":"airflow","slug":"airflow","link":"/tags/airflow/"}],"categories":[{"name":"oracle","slug":"oracle","link":"/categories/oracle/"},{"name":"settings","slug":"settings","link":"/categories/settings/"},{"name":"crawling","slug":"crawling","link":"/categories/crawling/"},{"name":"PL&#x2F;SQL","slug":"PL-SQL","link":"/categories/PL-SQL/"}]}